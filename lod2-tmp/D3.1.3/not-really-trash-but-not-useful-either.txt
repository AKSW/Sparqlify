\section{Ternary Logic}
\label{sec:ternary-logic}
Evaluation of SPARQL predicates follows a ternary logic composed of true (1), false (0) and type-error (e).
When translating expressions of type \emph{type-error} to SQL, they are treated as \emph{FALSE}.


\begin{figure}[!h]
\centering
\begin{tabular}{p{5cm}p{5cm}p{5cm}}

\begin{tabular}{|l|l|l|l|l|}
\multicolumn{5}{l}{\textbf{AND(a, b)}} \\
& \textbf{1} & \textbf{0} & \textbf{e} \\
\textbf{1} & 1 & 0 & e \\
\textbf{0} & 0 & 0 & 0 \\
\textbf{e} & e & 0 & e \\
\end{tabular}

&

\begin{tabular}{|l|l|l|l|l|}
\multicolumn{5}{l}{\textbf{OR(a, b)}} \\
& \textbf{1} & \textbf{0} & \textbf{e} \\
\textbf{1} & 1 & 1 & 1 \\
\textbf{0} & 1 & 0 & e \\
\textbf{e} & 1 & e & e \\
\end{tabular}

&

\begin{tabular}{|l|l|l|}
\multicolumn{3}{l}{\textbf{NOT(a)}} \\
\textbf{1} & 0 \\
\textbf{0} & 1 \\
\textbf{e} & e \\
\end{tabular}


\end{tabular}

\caption{Ternary Logic Truth Tables}
\end{figure}


\section{Rewriting Rules and Optimizations}
\begin{enumerate}
\item \emph{Constant folding} In general, any parts of expressions that only depend on constants are replaced by their evaluation.
Examples include: $+(1, 2) \rightarrow 3$ or $<(3, ``string'') \rightarrow type-error$ 
\item \emph{Short circut evaluation} Logical predicates are short circuit evaluated. For example $AND(FALSE, ?var) \rightarrow FALSE$. 
\item \emph{Equality of function expressions} Given a deterministic, injection function $f$, the following transformation can be applied: $f(a_1,\ldots, a_n) == f(b_1, \ldots, b_n) \rightarrow \bigwedge_{i = 1\ldots n}{a_i == b_i}$
\item \emph{Constant-Concat equality} In this case expand the constant with a concat: $c = concat(args) \rightarrow concat(c) = concat(args)$. This enables the application of the next rule. 
\item \emph{Equality of concat-expressions}
$concat(a_1, \ldots, a_n) = concat(b_1, \ldots, b_m) \rightarrow non-equivalence transformation as explained$\todo{Practical optimization approach: The longer array splits the shorter one on common substrings. If the arrays end up with same length}
\item \emph{Url encoding and decoding}
\begin{math}
urlencode(expr) = const \rightarrow expr == urldecode(const)
urldecode(expr) = const \rightarrow expr == urlencode(const) 
\end{math}
\item \emph{Inequality} \todo{to be done} 
\end{enumerate}
