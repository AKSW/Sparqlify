\newpage
\subsection{Mapping TODO Check if this is redundant}
\begin{figure}[!h]
\centering
\begin{tabular}{p{5.5cm}p{8.5cm}}
\toprule
Table & Sparqlify Mapping \\ 
\midrule

\begin{tabular}{|l|l|l|} \cline{1-2}
\multicolumn{2}{|c|}{resource\_label} \\ \hline
\textbf{resource} & \textbf{label} & \textbf{lang} \\ \hline
lgdo:Bakery & Baeckerei & de \\ \hline
lgdo:Bakery & Bakery    & en \\ \hline
lgdo:School & Schule    & de \\ \hline
\end{tabular}

&

\begin{minipage}{8.5cm}
\begin{scriptsize}
\begin{verbatim}
Prefix lgdo: <http://linkedgeodata.org/ontology/>
Prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
Create View labels As
    Construct {
        ?s rdfs:label ?l .
    }
    With
        ?s = uri(?resource)
        ?l =  plainLiteral(?label, ?lang)
    Constrain
        ?s prefix "http://linkedgeodata.org/ontology/"
    From
        resource_label
\end{verbatim}
\end{scriptsize}
\end{minipage}

\\

\multicolumn{2}{l}{Resulting RDF} \\ \midrule
\begin{minipage}{\textwidth}
\begin{lstlisting}
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

<http://linkedgeodata.org/ontology/Bakery> rdfs:label "Baeckerei"@de, "Bakery"@en .
<http://linkedgeodata.org/ontology/School> rdfs:label "Schule"@de .
\end{lstlisting}
\end{minipage}

\\

\bottomrule
\end{tabular}
\caption{Mapping of the resource label table.}
\label{fig:ex:mapping:resource_label}
\end{figure}


\section{Chaos below}


\subsection{Relation-Triple Mapping}
The problem of SPARQL-SQL rewriting is sometimes stated as "rewriting a SPARQL query into an equivalent SQL query (or set thereof)".
However, this is in fact just half of the problem statement; the other half being how to do the bookkeeping of the correspondences
between the SQL result set and the desired SPARQL result set.
This raises the question of what this bookkeeping should look like.
As it turns out, a Sparqlify-ML already capable of expressing \emph{any} correspondence between a relation (i.e. a SQL result set) and an RDF graph.
Analogous to the SPARQL syntax and SPARQL algebra, there is the Sparqlify-(View Definition)-Syntax, and the Sparqlify specific extension to the SPARQL algebra. 


%%However, Sparqlify-ML is located at the \emph{syntactic} level, whereas for the implementation more algebraic objects are desired:
%%\todo{Was ich sagen will: Sparqlify-ML ist syntaktisch, hat daher syntactic noise, und daher soll eine noise-free structur abgeleitet werden; z.B. variablen indiziert}




SqlNode {
    sparqlVarToExprs
    columnToExpr
}
 


\subsection{Column-RDFTerm relation}
The heart of the view definitions are the variable bindings that define SPARQL variables as expressions over zero or more SQL columns. 
These bindings always take the form:
\begin{verbatim}
sparql-var = rdf-term-constructor(expr)
\end{verbatim}
where:
\begin{itemize}
	\item \texttt{sparql-var} is a plain SPARQL variable, e.g. ?s, ?p, \ldots
	\item \texttt{rdf-term-constructor} is a function symbol that constructs RDF terms from its arguments.
	\item \texttt{expr} is an expression according to the \emph{SparqlifyBindingAlgebra}, such as \verb|concat("http://ex.org", ?id)| or \verb|urlencode(?name)|.
		It is important to note, that these expressions are conceptually neither SQL nor SPARQL expressions per se.
		However, these expressions can be compiled to expressions in either of these worlds.

		For example, the expression \verb|concat("http://ex.org", ?id)| can be pushed down into the projection of an SQL query, or it can   
\end{itemize}



\begin{verbatim}
    ?s = uri(concat("http://ex.org/person/", ?id));
    ?p = uri(?my_uri_column)
    ?o = typedLiteral(?value, xsd:float) 
\end{verbatim}
The general form is


\todo{yada yada}
The remainder of the technical documentation is structured as follows:
First we introduce the Sparqlify Mapping Language, which is a concise and intuitive language for expressing RDF views on relations.
Afterwards we give some basic insights into the SPARQL and SQL algebra.
The mapping language and the algebras form the basis for the subsequently explained SPARQL-SQL rewriting process: 
The main phases of idea of our approach are:
\begin{enumerate}
	\item Convert a SPARQL query string into a quad-based SPARQL algebra representation.
	\item Derive a new algebraic expression by substituting the quads with instances of suitable view definitions.
	\item Convert the derived expression into the SQL algebra, thereby keeping track of how the variables of the original SPARQL query relate to the tables of the RDBMS.
		We refer to these relations as \emph{bindings}.
	\item Serialize the SQL algebra as an SQL string.
	\item Send the SQL string to the RDBMS and retrieve its result.
	\item Create an appropriate SPARQL result for the original SPARQL query based on the SQL result set and the bindings.
\end{enumerate}

During the rewriting process we can apply various optimizations, such as the
optimization of filter placement, the elimination of self-joins and the removal
of unsatisfiable parts.



\todo{Image with the result.}

\section{The SPARQL-SQL rewriting process}
\subsection{Outline}
The prerequisite for rewriting SPARQL queries to SQL is a set of view
definitions on which to answer a query. A high level
outline of the process for answering a SPARQL query over such a set of views consists of
three steps:

\begin{itemize}
	\item[Candidate view selection.] 
		First, all candidate views have to be identified. 
		These are views that potentially contribute to the query's result set:
		Informally, this is the set of views that yield triples that could match the triple patterns of the query, as shown in Figure~\todo{ref}.
		\todo{We work on the algebra level.}

		It is important to note that during this process we obtain a set of mappings from the variables of
		the query to the variables and constants of the views. 
		We refer to such a mapping as \emph{binding}. 
		A detailed description \todo{comes later}.

		\item[Query rewriting.] 
			The identified candidate views and the obtained bindings enable us to rewrite a SPARQL query to an SQL query as well as keep track of how the variables of the SPARQL query are bound to (expressions over) the columns of the rewritten SQL query.
		\item[Result set rendering.] 
			The rewritten SQL query is executed and RDF terms are constructed for each SQL result set row according to the bindings being kept track of during the rewriting step.
			Based on the RDF terms, the appropriate result sets are rendered for the Ask, Construct, Select and Describe query types.
\end{itemize}


\subsection{Candidate View Selection}
In this section we explain how for a given SPARQL query appropriate view candidates are identified. 
\todo{Essentially, this is the view paper}.

\section{The Sparqlify Engine}

Listing~\ref{code:view} depicts an example of an RDB-RDF view definition
expressed in Sparqlify-ML. 
Such definition consists of four clauses, namely \emph{Construct}, \emph{With}, \emph{Constrain} and \emph{From}, which we explain as follows:
\begin{itemize}
  \item The \emph{Construct clause} is a set of quad-pattern 'C', where variables are allowed.
  \item The \emph{From clause} corresponds to a logical table $t$, with attr(r) being
  the column names, type(r, a) being the datatype of attribute a in relation r.
  \item Informally, the \emph{With clause} is a set of variable bindings that
  describe how SPARQL variables are constructed from the logical table.
	This implies that the datatype of the left hand side must be 'RDF term'. 
  A special function called 'rdfTerm', acts as bridge between the relational
  and RDF level:
	It takes four SQL expressions as arguments, namely (type, value, datatype, language-tag) and returns an rdfTerm.  %S x S x S x S -> T
\end{itemize}



\begin{lstlisting}[caption=Product instances and their types in the BSBM database,label=code:view]
Prefix bsbm-inst:<http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/>

Create View view_producttypeproduct As
  Construct {
    ?product a ?productType .
  }
  With
    ?product     = uri(concat(bsbm-inst:dataFromProducer, ?producer, "/Product", ?nr))
    ?productType = uri(concat(bsbm-inst:ProductType, ?producttype))
  From 
    [[SELECT a.nr, a.producer, b."producttype" FROM product a JOIN producttypeproduct b ON (b.product = a.nr)]]
\end{lstlisting}




\begin{lstlisting}[caption=View for the table co\_n from the Wortschatz database,label=code:view]
Prefix xsd:<http://www.w3.org/2001/XMLSchema#>
Prefix owl:<http://www.w3.org/2002/07/owl#>

prefix wso:<http://aksw.org/wortschatz/ontology/>
Prefix wss:<http://aksw.org/wortschatz/sentence/>

Create View view_co_n As
	Construct {
		?a wso:coOccursDirectlyWith ?b .
		?x owl:annotatedSource ?a .
		?x owl:annotatedProperty wso:coOccursDirectlyWith .
		?x owl:annotatedTarget ?b .
		?x wso:frequency ?f .
		?x wso:sigma ?s .
	}
	With
		?a = uri(concat('http://aksw.org/wortschatz/word/', ?w1_id))
		?b = uri(concat('http://aksw.org/wortschatz/word/', ?w2_id))
		?x = uri(concat('http://aksw.org/wortschatz/co-occurence/direct/', ?w1_id, '/', ?w2_id))
		?f = typedLiteral(?freq, xsd:long) 
		?s = typedLiteral(?sig, xsd:long)
	From
		[[SELECT w1_id, w2_id, freq::bigint, sig::bigint FROM co_n]];
\end{lstlisting}

\begin{lstlisting}[caption=A view for a "static" set of triples,label=code:view_static_triples]
Create View dataset_metadata
    As Construct {
        <http://linkedgeodata.org>
        	ex:maintainer <http://claus-stadler.org/webid#me> .
       	<http://claus-stadler.org/webid#me> a foaf:Person ; foaf:firstName
       	"Claus" .       	
	}
\end{lstlisting}



The Sparqlify Mapping Language features the following:
\begin{itemize}
  \item[Support for expressive mappings] Any triple and any RDF term (i.e. blank
  node, URI, plain and typed literal) can be constructed from a table. 
  \item[Intuitive Syntax] The Sparqlify-ML syntax reuses elements
  already known from the original SPARQL grammar,
  namely the Construct-clause and the expression syntax. For this reason,
  the language should be easy-to-learn for users that already know
  SPARQL. Unlike many other RDB-RDF approaches, there is no need to learn any special RDF vocabulary or XML markup.
  \item[Clear concept] Sparqlify-ML enables a concise description of the
  relation between a table and the triples to be constructed from it.  
\end{itemize}


\begin{lstlisting}

List the URIs and optionally the comments of those resources that appear as the subject and the object in the same triple.


Views:
sql_comments
rdfs:Class "The class of classes."
ex:Leipzig ex:City .

sql_types
rdfs:Class rdfs:Class .


Create View comments As
  Construct {
     ?x rdfs:comment ?y .
  } With
     ?x = uri(?cs)
     ?y = uri(?co)
  From
    [[Select subject As cs, object As co From sql_comments]]


Create View types As
  Construct {
     ?x rdf:type ?y .
  } With
     ?x = uri(?ts)
     ?y = uri(?to)
  From
    [[Select subject As ts, object As to From sql_comments]]


Virtual RDF Graph:
bif:contains isSpecialPredicate bif:contains.

rdfs:Class a rdfs:Class ;
    rdfs:comment "The class of classes." .


Query A:
Select Distinct ?s ?o {
  ?s ?t ?s .
  ?s rdfs:comment ?o .
}


Query B
Select Distinct ?s ?o {
  ?s ?t ?s .
  Optional {
      ?s rdfs:comment ?o .
  }
}


\begin{minipage}{4cm}
\begin{scriptsize}
\begin{verbatim}
Select Distinct ?s ?o {
  ?s ?t ?s .
  Optional {
      ?s rdfs:comment ?o .
  }
}
\end{verbatim}
\end{scriptsize}
\end{minipage}





Yay, Virtuoso bug discovered.... it returns a wrong result set.
Workaround: Write as below:

Select Distinct ?s ?o {
  ?s ?t ?a .
  Optional {
      ?b rdfs:comment ?o .
      Filter(?a = ?b)
  }
  Filter(?s = ?a) .
}



Expected result:
?s	?o
rdfs:Class	"The class of classes."
bif:contains	NULL


Select Distinct ?s ?o {
  ?s ?v1 ?o .
  Filter(?v1 = rdfs:comment) .
}


Algebra
Project((?o),  
  Left Join(
    QPS(
    {?s ?t ?s}),
    Filter(
      ?p = rdf:comment,
  	  QPS({?s ?p ?o })
  	)
  )
)

\end{lstlisting}


\section{Implementation}
\subsection{Jena}
\begin{lstlisting}[caption=SPARQL: From query string to algebra using Jena, label=code:sparql-string-to-algebra]
import com.hp.hpl.jena.query.QueryFactory;
import com.hp.hpl.jena.query.Query;
import com.hp.hpl.jena.sparql.algebra.Algebra;
import com.hp.hpl.jena.sparql.algebra.Op;
	
String queryString = "Select * { ?s ?p ?o }";
Query query = QueryFactory.create(queryString); 		
Op op = Algebra.compile(query);
Op opQuads = Algebra.toQuadForm(op);		
\end{lstlisting}
